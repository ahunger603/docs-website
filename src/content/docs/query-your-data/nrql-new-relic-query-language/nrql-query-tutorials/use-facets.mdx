---
title: 'NRQL: Understanding FACET, NRQLs GROUP_BY'
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - NRQL query deep-dive
metaDescription: 'NRQL deep-dive on FACET and how it compares to SQL GROUP_BY'
redirects:
freshnessValidatedDate: never
---

import queriesBasicFacet from 'images/queries_screenshot-crop-average-nrdb-query.webp'

import queriesBasicColumns from 'images/queries_screenshot-crop-basic-nrdb-query-select-star.webp'

import queriesTopKLimit3 from 'images/queries_screenshot-crop-topk-example.webp'

import queriesTopKLimit3Alternative from 'images/queries_screenshot-crop-topk-alternative-example.webp'

import queriesFacetCases from 'images/queries_screenshot-crop-facet-cases.webp'

import queriesOrderBy from 'images/queries_screenshot-crop-facet-order-by.webp'

import queriesLabeledFacet from 'images/queries_screenshot-crop-labeled-facets.webp'

import queriesTimeseriesFacet from 'images/queries_screenshot-crop-facet-timeseries.webp'

import queriesTupleFacet from 'images/queries_screenshot-crop-tuple-facet.webp'


NRQL has many visual similarities to SQL, but one major difference is the exclusion of the `GROUP_BY` clause. Instead, NRQL uses the `FACET` clause for grouping data together. In this doc, we'll explore the `FACET` clause and expand on the differences between `GROUP_BY` and `FACET` to explain why we've named these differently.

The `FACET` clause allows you to arbitrarily group data into the aggregation(s) of your choosing. You can look at the `NrdbQuery` event type which appears in all accounts, and represents the execution of a single query against NRDB. You can see that data by using the following query and selecting the columns that display:
```sql
FROM NrdbQuery SELECT durationMs, query.eventType
```
<img
  title="NrdbQuery Columns"
  alt="A screenshot displaying the columns of the NrdbQuery event"
  src={queriesBasicColumns}
/>

Each NrdbQuery has an associated `durationMs`, and `query.eventType`. You can use `FACET` to find the average duration of each NrdbQuery by their target event type.
```sql
FROM NrdbQuery SELECT average(durationMs) FACET query.eventType
```
<img
  title="NrdbQuery Facet Average"
  alt="A screenshot displaying the average duration of NrdbQuery event by their event type"
  src={queriesBasicFacet}
/>

Faceting is an essential tool for analyzing your data. Combining it with the `TIMESERIES` clause enables you to see groupings across time. For more information, see the [advanced faceting](#advanced) section below.

## Facet with limiting [#limits]

Limiting is a key difference between `FACET` and `GROUP_BY`. By default, a NRQL facet clause only provides 10 groups, even when more than 10 groups exist in the data set. You can adjust this limit by providing `LIMIT <k>` at the end of the query, with `<k>` as a value between 1 and 2000. You can also use `LIMIT MAX` if you'd like to default to the highest value. Since NRDB is a multi-tenant system, you must limit queries to ensure all users have a consistent and issue-free querying performance.

<Callout variant="tip">
  Keep `FACET` limits in mind when designing your internal event data model. If you have larger values that you're planning to facet by, consider breaking those values across distinct event types to ensure your event types fall below the `LIMIT MAX`.
</Callout>

### Facet using group selection [#group-selection]

In the situation where the number of groups exceeds the provided `LIMIT <k>`, NRDB must select which groups to provide within the given limit. Group selection is the most important and distinct difference between `FACET` and `GROUP_BY`. In general, the group selection works by finding the "top-k" for the first aggregation provided in the query. For example:

```sql
FROM NrdbQuery SELECT count(*), average(durationMs) FACET query.eventType LIMIT 3
```
<img
  title="NrdbQuery Facet Limit 3"
  alt="A screenshot displaying the result of a limit 3 query with count first"
  src={queriesTopKLimit3}
/>

In the example above, you can see the top 3 `query.eventType`s with the highest `count(*)` results. In the example, the top value was a count of `20`. Importantly, the `average(durationMs)` was **not** used to decide the top 3 and didn't impact the facet group selection. If you wanted to see the `query.eventType` by sorted by highest `durationMs`, you'd need to change the order of the `SELECT` clause, as such:

```sql
FROM NrdbQuery SELECT average(durationMs), count(*) FACET query.eventType LIMIT 3
```
<img
  title="NrdbQuery Facet Limit 3 Average First"
  alt="A screenshot displaying the result of a limit 3 query with average first"
  src={queriesTopKLimit3Alternative}
/>

Now you can see the different labels sorted by their average `durationMs`!

<Callout variant="important">
  When combining the `FACET` and `COMPARE WITH` clauses, the facets are chosen based on the most recent time window of the query. If the value you're faceting changes frequently, your past time window may appear empty.
</Callout>

### Facet with alternative group selection [#order-by]

In some cases, you might like to find groups based on an aggregation that's *different** from your first aggregation and want to exclude the alternative selection aggregation from your results. You can do this by using `FACET ... ORDER BY` with the following syntax:

```sql
FROM NrdbQuery SELECT count(*) FACET query.eventType ORDER BY average(durationMs) LIMIT 3
```
<img
  title="NrdbQuery Facet Order By"
  alt="A screenshot displaying the result of a facet order by query"
  src={queriesOrderBy}
/>

In the above result, each `query.eventType` was chosen for having the highest average `durationMs`, but they only return the aggregations select clause (`count` in this case).

<Callout variant="caution">
  In `FACET ... ORDER BY`, the `ORDER BY` must follow immediately after the `FACET` clause. If there's another clause between those, like `SINCE` / `UNTIL`, it will be treated differently and will generally be ignored. Additionally, the `ORDER BY &gt;function&lt;` function argument must be an aggregation, such a top-k supported aggregation. For more info, see the [top-k supported aggregations](#supported-functions) section below.
</Callout>

### Approximate in group selection [#group-selection-approximation]

NRDB is a highly distributed system. The data for a given query may be spread across numerous different hosts across different availability zones. As a result, the top-k must approximate the sorted order of your groups to decide what groups can fit within the limit. In general, the top resuts have high accuracy, while the end results have diminishing accuracy.

<Callout variant="tip">
  The accuracy of the approximations within the top-k selection algorithms increases with the `LIMIT &gt;k&lt;`. If the accuracy of the top values has high importance, consider increasing the `LIMIT` value, even if the following values aren't important for your use-case.
</Callout>

#### Top-k supported aggregations [#supported-functions]
The approximations NRDB must make to decide the sorted order of the facets are non-trivial algorithms which tailored for individual use-cases. Only a handful of functions have full supported top-k algorithms associated with them. See the lost of those algorithms below:

* `Count-k`, the default option for all functions without a specific algorithm assigned
* `Sum-k`, implemented for `sum`
* `Average-k`, implemented for `average`, `percentile` and `median`
* `Min-k`, implemented for `min`
* `Max-k`, implemented for `max`

This is a simplified overview. In many cases, NRDB will alter which algorithm it uses. For example, the `rate(...)` or `filter(...)` function will use their first argument as the top-k algorithm, rather than defaulting to `count-k`.

## Advanced Faceting [#advanced]
Now that you have a stronger grasp over `FACET` and some of its technical details, we can explore some example queries which can help improve your usage of NRQL!

### Facet Timeseries [#facet-timeseries]
NRDB is a database specialized in timeseries data, so it's common to want to visualize your facet groups by time. To do that, you can use the `TIMESERIES` clause:

```sql
FROM NrdbQuery SELECT count(*) FACET query.eventType TIMESERIES
```
<img
  title="NrdbQuery Facet Timeseries"
  alt="A screenshot displaying the result of a facet timeseries query"
  src={queriesTimeseriesFacet}
/>

### Tuple Faceted [#face-tuple]
Unlike the examples so far, `FACET` can accept multiple values! Each group is formed by the unique tuple of values found for each row, such as in this example:

```sql
FROM NrdbQuery SELECT count(*) FACET query.eventType, source.name
```
<img
  title="NrdbQuery Tuple Faceted"
  alt="A screenshot displaying the result of a facet tuple query"
  src={queriesTupleFacet}
/>


### Facet Labeling (AS) [#face-labeling]
You may have cases where you'd like to change the default label provided for a given group. As shown below, you can use the `AS` clause to rename any particular grouping:
```sql
FROM NrdbQuery SELECT count(*) FACET hourOf(timestamp) AS 'Timestamp Hour'
```
<img
  title="NrdbQuery Facet Labeling"
  alt="A screenshot displaying the result of a labeled facet query"
  src={queriesLabeledFacet}
/>

### Facet Cases [#face-cases]
The `cases` function is particularly useful in the `FACET` clause to create advanced groupings. `cases` takes a list of arguments, where each argument is a filter applied in the row to categorize the events into labels, such as in this example:

```sql
FROM NrdbQuery SELECT count(*) FACET cases(durationMs > 100 as '>100', durationMs > 50 as '>50', durationMs > 0 as '>0')
```
<img
  title="NrdbQuery Facet Cases"
  alt="A screenshot displaying the result of a facet cases query"
  src={queriesFacetCases}
/>

### Manual Facet Selection Optimization [#manual-selection]
Sometimes, you may already know what facet values you want to select. To do so, you can manually enter the facet value selection `IN` to avoid the cost of running the `top-k` approximation algorithm. Doing this can double query performance in many cases! Here's an example you can try:

```sql
FROM NrdbQuery SELECT average(durationMs) FACET query.eventType IN ('NrConsumption', 'Metric')
```
The above query forces the result to exclusively group into `query.eventType` values.
